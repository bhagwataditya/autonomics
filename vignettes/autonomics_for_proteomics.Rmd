---
title: "Autonomics for Proteomics"
author: "Aditya M Bhagwat"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{autonomics_for_proteomics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, cache = TRUE, fig.show = 'hold')
```

This vignette demonstrates how to use `autonomics` for proteomics data analysis.

# Samples

## Design

Fukuda et al. (2020) studied the embryonic development of zebrafish.  
They compared the proteome of 30-days-post-fertilization embryos to adults.


```{r, message = FALSE}
require(autonomics)
file <- download_data('fukuda20.proteingroups.txt')
object <- read_proteingroups(file, plot = FALSE)
sdt(object)[, 1:3]
```

## Principle Component Analysis

In an experiment with p quantified proteingroups, each sample can be thought of as a data point in a p-dimensional space. **Principal Component Analysis** projects these sample points onto that lower (e.g. 2) dimensional space which maximizes the variance between samples. This two-dimensional biplot greatly aids in comprehending the overall sample similarity structure, as shown below for the dataset under consideration, where subgroup is reassuringly observed to be the major source of variation.


```{r, message = FALSE, fig.width = 3.5, fig.height = 2.5, out.width = '50%', out.height = '50%'}
biplot(pca(object))
```

## Sample Distributions

A sample distribution shows how the values of a **single sample** are distributed **across all features** (proteins).
Sample distributions can be visualized with density, violin, or box plots, as shown below.


```{r, message = FALSE, fig.with = 10, fig.height = 2.75}
require(ggplot2)
d <- plot_sample_densities(object) + guides(fill = 'none')
v <- plot_sample_violins(object)   + guides(fill = 'none')
b <- plot_sample_boxplots(object)  + guides(fill = 'none')
gridExtra::grid.arrange(d, v, b, nrow = 1)
```


# Features

## Filtering

```{r}
n <- analysis(object)$nfeature
```

**`r n[[5]]` proteingroups** (out of `r n[[1]]` identified) were retained for further analysis, after applying the following filters:


```{r, echo = FALSE}
require(data.table)
data.table(Filter = names(n), n = n)   # Filtering details
```

## Feature Distributions

A feature (protein) distribution shows how the values of a **single feature** are distributed **across all samples**.
Feature distributions can be visualized with density, violin, or box plots, as shown below.


```{r, message = FALSE, fig.with = 10, fig.height = 2.75}
require(ggplot2)
d <- plot_feature_densities(object, n = 4) + guides(fill = 'none')
v <- plot_feature_violins(  object, n = 4) + guides(fill = 'none')
b <- plot_feature_boxplots( object, n = 4) + guides(fill = 'none')
gridExtra::grid.arrange(d, v, b, nrow = 1)
```

# Missing values

## Systematic versus Random

```{r}
systematic <- sum(systematic_nas(object))
random     <-     sum(random_nas(object))
no         <-         sum(no_nas(object))
```


**`r systematic`** proteingroups have **systematic** NAs: missing completely in some subgroups but detected in others (for at least half of the samples). These represent potential switch-like responses. They require prior imputation for statistical analysis to return p (rather than NA) values. Note that the apparent systematic nature of these NAs can arise due to chance. Increasing sample size gives greater  confidence into the systematic nature of these NA values.

**`r random`** proteingroups have **random** NAs. They are missing in some samples, but the missingness is unrelated to subgroup. These samples do not require require imputation for statistical analyis to return pvalues.  

**`r no`** proteingroups have **no** NAs. They are present in all samples.  

## Plotting NA structure
  
The NA structure can also be summarized graphically with either of the two functions below.  

```{r, echo = TRUE, results = 'hide', message = FALSE, fig.width = 6, fig.height = 3, out.width = '100%', out.height = '100%'}
p1 <- plot_sample_nas(object) + ggplot2::guides(fill = 'none')
p2 <- plot_subgroup_nas(object)
gridExtra::grid.arrange(p1, p2, nrow = 1)
```

`plot_sample_nas` shows NA structure at **sample** resolution, plotting systematic and random NAs (white) as well as full detections (bright color).  
`plot_subgroup_nas` summarizes NA structure at the **subgroup** level, differentiating systematic NA values (white) from random NA values and full detections (color).

## Imputing systematic NAs

Proteingroups with systematic misses require prior imputation for statistical analysis to return pvalues (rather than missing values). 

```{r, echo = TRUE, results = 'hide', message = FALSE, fig.cap = 'Left: sample distributions, Right: detections'}
require(magrittr)
object %<>% impute(plot = TRUE)
```
The sample distributions (left) show how imputed values are drawn from a normal distribution, 2.5 standard deviations away from the sample mean, 0.3 standard deviations wide.  

The detection plot (right) shows imputed values with a lighter color.

# Differential Expression

## `fit_lm`: General Linear Model

### $t$ statistic and $p$ value {-}

Diffferential Expression Analysis quantifies whether subgroup differences are significant. The current example dataset has two subgroups (X30dpt and Adults), each with three replicates.

```{r}
table(object$subgroup)
```

The t-statistic expresses the **difference** between two subgroups in terms of **standard error (SE)** units (i.e. standard devation, normalized for sample size):

$$t = \frac{\textrm{difference}}{\frac{\textrm{sd}}{\sqrt n}}$$
When samples from two subgroups are many SE units away from each other, the $t$ value will be large, and the difference likely arose due to true subgroup differences.  
When samples from two different subgroups are close to each other, on the other hand, the $t$ value will be small, and the probability that the difference arose due to random sampling is high. This probability (that the difference arose due to random sampling) is known as the **p value**. The p value expresses a signal (difference) to noise (standard error) ratio, and is very useful for feature (protein) prioritization. A general convention is to call $p$ < 0.05 differences significant.

### General Linear Model and `lm` {-}

The General Linear Model generalizes the (two-subgroup) t-test to multiple subgroups (e.g. $t_0$,  $t_1$, $t_2$), multiple factors (e.g. time and concentration), as well as numerical covariates (e.g. age and  bmi) in a unified modeling framework. In R its classical implementation is the `lm` modeling engine, to which autonomics offers direct access:

```{r}
  require(magrittr)
  object %<>% fit_lm()
```

```{r, echo = FALSE, message = FALSE}
  summary <- summarize_fit(object, 'lm')[contrast=='subgroupAdult']
  systime <- system.time(object %<>% fit_lm())
```

In the example dataset `lm` found `r summary$ndown` age-associated downregulations and `r summary$nup` upregulations. Running `lm` on `r nrow(object)` proteins took no more that `r systime[[3]]` seconds, a feat achieved through a performant backend that integrates `lm` into a `data.table` environment.

### Flexibile Model Definitions {-}

Autonomics provides different ways to specify the model, aimed at serving the tastes of laymen as well as experts, and all levels between.

The simplest approach is to rely on the  automated **defaults**, which build a model (with intercept) using the sample variable 'subgroup'. A more flexible option is to specify **subgroupvar**, allowing  this variable to be used in model building. Yet more flexibility is provided through the **formula** interface, allowing to drop intercept, include multiple factors, or numeric covariates. Full flexibility (e.g. the ability to customize coefficient names) is achieved through the **design** matrix interface. These different options are illustrated below, all are equivalent, serving different tastes.


```{r, eval = FALSE}
object %<>% fit_lm()
object %<>% fit_lm(subgroupvar = 'subgroup')
object %<>% fit_lm(formula = ~ subgroup)
# object %<>% fit_lm(design = create_design(object, ~ subgroup)) # works only for limma currently
```


### Changing the coefficient meanings {-}

By default the $\beta_{\textrm{Intercept}}$ coefficient represents the level of the first subgroup, and subsequent coefficients (e.g. $\beta_{\textrm{Adult}}$) differences to that first subgroup.

```{r}
object %<>% fit_lm()
```

```{r, echo = FALSE, fig.width = 5, fig.height = 3, out.width='30%', out.height='30%'}
plot_treatment_coefs(object)
```

Ths can be changed. 
A more advanced approach is to use other coefficient coding systems. By default R uses treatment contrast coding, in which each coefficient represents difference to the first subgroup. 

```{r}
contrasts(object$subgroup)

contrasts(object$subgroup) %<>% contr.sum() # Use sum rather than treatment contrasts
object %<>% fit_lm()
```


 
## `fit_limma`: Moderated GLM and Generalized Contrasts

```{r}
  object %<>% fit_limma()                          # rely on defaults
```


```{r}
# object %<>% fit_limma(subgroupvar = 'subgroup')  # specify subgroup variable
# object %<>% fit_limma(formula = ~ subgroup)    # specify model formula
# object %<>% fit_limma(design = create_design(formula = ~ subgroup)) # design matrix
```