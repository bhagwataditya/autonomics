---
title: "Autonomics for Proteomics"
author: "Aditya M Bhagwat"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{autonomics_for_proteomics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, cache = TRUE, fig.show = 'hold')
```

This vignette demonstrates how to use `autonomics` for proteomics data analysis.

# MaxQuant ProteinGroups

## Samples

### Design {-}

Fukuda et al. (2020) studied the embryonic development of zebrafish.  
They compared the proteome of 30-days-post-fertilization embryos to adults.


```{r, message = FALSE}
require(autonomics)
file <- download_data('fukuda20.proteingroups.txt')
object <- read_proteingroups(file, plot = FALSE)
sdt(object)[, 1:3]
```

### Principle Component Analysis {-}

In an experiment with p quantified proteingroups, each sample can be thought of as a data point in a p-dimensional space. **Principal Component Analysis** projects these sample points onto that lower (e.g. 2) dimensional space which maximizes the variance between samples. This two-dimensional biplot greatly aids in comprehending the overall sample similarity structure, as shown below for the dataset under consideration, where subgroup is reassuringly observed to be the major source of variation.


```{r, message = FALSE, fig.width = 3.5, fig.height = 2.5, out.width = '50%', out.height = '50%'}
biplot(pca(object))
```

### Sample Distributions {-}

A sample distribution shows how the values of a **single sample** are distributed **across all features** (proteins).
Sample distributions can be visualized with density, violin, or box plots, as shown below.


```{r, message = FALSE, fig.with = 10, fig.height = 2.75}
require(ggplot2)
d <- plot_sample_densities(object) + guides(fill = 'none')
v <- plot_sample_violins(object)   + guides(fill = 'none')
b <- plot_sample_boxplots(object)  + guides(fill = 'none')
gridExtra::grid.arrange(d, v, b, nrow = 1)
```


## Features

### Filtering {-}

```{r}
n <- analysis(object)$nfeature
```

**`r n[[5]]` proteingroups** (out of `r n[[1]]` identified) were retained for further analysis, after applying the following filters:


```{r, echo = FALSE}
require(data.table)
data.table(Filter = names(n), n = n)   # Filtering details
```

### Feature Distributions {-}

A feature (protein) distribution shows how the values of a **single feature** are distributed **across all samples**.
Feature distributions can be visualized with density, violin, or box plots, as shown below.


```{r, message = FALSE, fig.with = 10, fig.height = 2.75}
require(ggplot2)
d <- plot_feature_densities(object, n = 4) + guides(fill = 'none')
v <- plot_feature_violins(  object, n = 4) + guides(fill = 'none')
b <- plot_feature_boxplots( object, n = 4) + guides(fill = 'none')
gridExtra::grid.arrange(d, v, b, nrow = 1)
```

## Missing values

### Systematic versus Random {-}

```{r}
systematic <- sum(systematic_nas(object))
random     <-     sum(random_nas(object))
no         <-         sum(no_nas(object))
```


**`r systematic`** proteingroups have **systematic** NAs: missing completely in some subgroups but detected in others (for at least half of the samples). These represent potential switch-like responses. They require prior imputation for statistical analysis to return p (rather than NA) values. Note that the apparent systematic nature of these NAs can arise due to chance. Increasing sample size gives greater  confidence into the systematic nature of these NA values.

**`r random`** proteingroups have **random** NAs. They are missing in some samples, but the missingness is unrelated to subgroup. These samples do not require require imputation for statistical analyis to return pvalues.  

**`r no`** proteingroups have **no** NAs. They are present in all samples.  

### Plotting NA structure {-}
  
The NA structure can also be summarized graphically with either of the two functions below.  

```{r, echo = TRUE, results = 'hide', message = FALSE, fig.width = 6, fig.height = 3, out.width = '100%', out.height = '100%'}
p1 <- plot_sample_nas(object) + ggplot2::guides(fill = 'none')
p2 <- plot_subgroup_nas(object)
gridExtra::grid.arrange(p1, p2, nrow = 1)
```

`plot_sample_nas` shows NA structure at **sample** resolution, plotting systematic and random NAs (white) as well as full detections (bright color).  
`plot_subgroup_nas` summarizes NA structure at the **subgroup** level, differentiating systematic NA values (white) from random NA values and full detections (color).

### Imputing systematic NAs {-}

Proteingroups with systematic misses require prior imputation for statistical analysis to return pvalues (rather than missing values). 

```{r, echo = TRUE, results = 'hide', message = FALSE, fig.cap = 'Left: sample distributions, Right: detections'}
require(magrittr)
object %<>% impute(plot = TRUE)
```
The sample distributions (left) show how imputed values are drawn from a normal distribution, 2.5 standard deviations away from the sample mean, 0.3 standard deviations wide.  

The detection plot (right) shows imputed values with a lighter color.

## Differential Expression

### Subgroups {-}

Diffferential Expression Analysis quantifies whether subgroup differences are significant. The current example dataset has two subgroups (X30dpt and Adults), each with three replicates.

```{r}
table(object$subgroup)
```

### Statistics: $t$ and $p$ {-}

The t-statistic expresses the **diff**erence between two subgroups in terms of **SE** units (standard error = standard devation, normalized for sample size):

$$t = \frac{\textrm{difference}}{\frac{\textrm{sd}}{\sqrt n}}$$
When samples from two subgroups are many SE units away from each other, the $t$ value will be large, and the difference likely raose due to true subgroup differences.  
When samples from two different subgroups are close to each other, on the other hand, the $t$ value will be small, and the probability that the difference arose due to random sampling is high. This probability (that the difference arose due to random sampling) is known as the **p value**. The p value expresses a signal (difference) to noise (standard error) ratio, and is very useful for feature (protein) prioritization. A general convention is to call $p$ < 0.05 differences significant.

### General Linear Model (GLM): `lm` {-}

The General Linear Model generalizes the (two-subgroup) t-test to multiple subgroups ($t_0$,  $t_1$, $t_2$), multiple factors (time and concentration), as well as numerical covariates (age, bmi) in a unified modeling interface. In R its classical implementation is the `lm` modeling engine, to which autonomics offers performant and easy access (`lm` calls are embedded into a data.table environment for performance). In the example dataset `lm` finds 713 age-associated upregulations and 1277 downregulations: 


```{r}
  require(magrittr)
  object %<>% fit_lm()
```

### GLM + Moderated Testing + Generalized Contrasts: `limma` {-}

```{r}
  object %<>% fit_limma()                          # rely on defaults
```


```{r}
# object %<>% fit_limma(subgroupvar = 'subgroup')  # specify subgroup variable
# object %<>% fit_limma(formula = ~ subgroup)    # specify model formula
# object %<>% fit_limma(design = create_design(formula = ~ subgroup)) # design matrix
```